{"version":3,"file":"ChatWindow-BTxqaZXb.js","sources":["../../src/utils/envValidation.ts","../../src/types.ts","../../src/memory/services/MemoryService.ts","../../src/memory/MemoryBank.ts","../../src/memory/storage/LocalStorageAdapter.ts","../../src/memory/config.ts","../../src/services/geminiService.ts","../../src/components/icons/SendIcon.tsx","../../src/components/ChatWindow.tsx"],"sourcesContent":["// Environment validation utility\ninterface EnvironmentConfig {\n  VITE_API_KEY: string;\n  VITE_WORKER_URL: string;\n  NODE_ENV: string;\n}\n\nclass EnvironmentError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'EnvironmentError';\n  }\n}\n\nexport function validateEnvironment(): EnvironmentConfig {\n  const config = {\n    VITE_API_KEY: import.meta.env.VITE_API_KEY,\n    VITE_WORKER_URL: import.meta.env.VITE_WORKER_URL || 'https://malnu-api.sulhi-cmz.workers.dev',\n    NODE_ENV: import.meta.env.NODE_ENV || 'development'\n  };\n\n  // Check for required environment variables\n  if (!config.VITE_API_KEY) {\n    throw new EnvironmentError(\n      'VITE_API_KEY tidak ditemukan. Silakan konfigurasi file .env dengan API key Google Gemini AI yang valid.\\n' +\n      'Dapatkan API key dari: https://makersuite.google.com/app/apikey'\n    );\n  }\n\n  if (config.VITE_API_KEY === 'your_google_gemini_api_key_here') {\n    throw new EnvironmentError(\n      'VITE_API_KEY masih menggunakan placeholder. Silakan ganti dengan API key Google Gemini AI yang sebenarnya.'\n    );\n  }\n\n  return config;\n}\n\nexport const env = validateEnvironment();\n\n// Export individual variables for convenience\nexport const API_KEY = env.VITE_API_KEY;\nexport const WORKER_URL = env.VITE_WORKER_URL;\nexport const NODE_ENV = env.NODE_ENV;","export enum Sender {\n  User = 'user',\n  AI = 'ai',\n}\n\nexport interface ChatMessage {\n  id: string;\n  text: string;\n  sender: Sender;\n}\n\n// Featured program data structure\nexport interface FeaturedProgram {\n  title: string;\n  description: string;\n  imageUrl: string;\n}\n\n// Latest news data structure\nexport interface LatestNews {\n  title: string;\n  date: string;\n  category: string;\n  imageUrl: string;\n}\n","import {\n  Memory,\n  MemoryQuery,\n  MemoryStorageAdapter,\n  MemoryBankConfig,\n  MemoryServiceInterface,\n  MemoryStats,\n  MemoryType\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Memory Service\n * Handles business logic for memory operations\n */\nexport class MemoryService implements MemoryServiceInterface {\n  private config: MemoryBankConfig;\n  private storageAdapter: MemoryStorageAdapter;\n\n  constructor(config: MemoryBankConfig) {\n    this.config = config;\n    this.storageAdapter = config.storageAdapter;\n  }\n\n  /**\n   * Add a new memory\n   */\n  async addMemory(\n    content: string,\n    type: MemoryType,\n    metadata?: Record<string, any>\n  ): Promise<Memory> {\n    const now = new Date();\n\n    const memory: Memory = {\n      id: uuidv4(),\n      content,\n      type,\n      timestamp: now,\n      metadata,\n      importance: this.config.defaultImportance || 0.5,\n      accessCount: 0\n    };\n\n    await this.storageAdapter.store(memory);\n    return memory;\n  }\n\n  /**\n   * Get a memory by ID\n   */\n  async getMemory(id: string): Promise<Memory | null> {\n    const memory = await this.storageAdapter.retrieve(id);\n\n    if (memory) {\n      // Update access tracking\n      await this.updateMemory(id, {\n        accessCount: memory.accessCount + 1,\n        lastAccessed: new Date()\n      });\n      return await this.storageAdapter.retrieve(id); // Return updated memory\n    }\n\n    return null;\n  }\n\n  /**\n   * Search memories based on query\n   */\n  async searchMemories(query: MemoryQuery): Promise<Memory[]> {\n    return this.storageAdapter.search(query);\n  }\n\n  /**\n   * Update an existing memory\n   */\n  async updateMemory(id: string, updates: Partial<Memory>): Promise<void> {\n    // Preserve access count if not explicitly updated\n    if (updates.accessCount === undefined) {\n      const existing = await this.storageAdapter.retrieve(id);\n      if (existing) {\n        updates.accessCount = existing.accessCount;\n      }\n    }\n\n    await this.storageAdapter.update(id, updates);\n  }\n\n  /**\n   * Delete a memory\n   */\n  async deleteMemory(id: string): Promise<void> {\n    await this.storageAdapter.delete(id);\n  }\n\n  /**\n   * Get relevant memories based on context similarity\n   */\n  async getRelevantMemories(context: string, limit = 10): Promise<Memory[]> {\n    // Simple keyword-based relevance scoring\n    const allMemories = await this.storageAdapter.getAll();\n\n    const relevantMemories = allMemories\n      .map(memory => {\n        const content = memory.content.toLowerCase();\n        const contextWords = context.toLowerCase().split(/\\s+/);\n        const metadata = memory.metadata || {};\n\n        let score = 0;\n\n        // Content relevance\n        contextWords.forEach(word => {\n          if (word.length > 2) { // Ignore short words\n            const occurrences = (content.match(new RegExp(word, 'g')) || []).length;\n            score += occurrences * memory.importance;\n          }\n        });\n\n        // Type relevance\n        if (memory.type === 'context' || memory.type === 'fact') {\n          score *= 1.5;\n        }\n\n        // Recency bonus (newer memories are more relevant)\n        const daysSinceCreation = (Date.now() - memory.timestamp.getTime()) / (1000 * 60 * 60 * 24);\n        const recencyBonus = Math.max(0, 1 - daysSinceCreation / 30); // 30-day window\n        score *= (1 + recencyBonus);\n\n        // Access count bonus (frequently accessed memories are more relevant)\n        const accessBonus = Math.min(memory.accessCount * 0.1, 0.5);\n        score *= (1 + accessBonus);\n\n        return { memory, score };\n      })\n      .filter(({ score }) => score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(({ memory }) => memory);\n\n    return relevantMemories;\n  }\n\n  /**\n   * Perform cleanup operations\n   */\n  async cleanup(): Promise<number> {\n    const allMemories = await this.storageAdapter.getAll();\n    const maxMemories = this.config.maxMemories || 1000;\n\n    if (allMemories.length <= maxMemories) {\n      return 0; // No cleanup needed\n    }\n\n    // Sort memories by importance and recency for cleanup\n    const sortedMemories = allMemories.sort((a, b) => {\n      const aScore = a.importance + (a.accessCount * 0.1) +\n        (1 / (1 + (Date.now() - a.timestamp.getTime()) / (1000 * 60 * 60 * 24))); // Recency bonus\n      const bScore = b.importance + (b.accessCount * 0.1) +\n        (1 / (1 + (Date.now() - b.timestamp.getTime()) / (1000 * 60 * 60 * 24)));\n\n      return aScore - bScore; // Lower scores first (to be deleted)\n    });\n\n    // Keep the top memories, delete the rest\n    const memoriesToKeep = sortedMemories.slice(0, maxMemories);\n    const memoriesToDelete = sortedMemories.slice(maxMemories);\n\n    // Delete memories that are no longer needed\n    for (const memory of memoriesToDelete) {\n      await this.storageAdapter.delete(memory.id);\n    }\n\n    return memoriesToDelete.length;\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    const allMemories = await this.storageAdapter.getAll();\n\n    const memoriesByType = allMemories.reduce((acc, memory) => {\n      acc[memory.type] = (acc[memory.type] || 0) + 1;\n      return acc;\n    }, {} as Record<MemoryType, number>);\n\n    const averageImportance = allMemories.length > 0\n      ? allMemories.reduce((sum, memory) => sum + memory.importance, 0) / allMemories.length\n      : 0;\n\n    // Get storage size if adapter supports it\n    let storageSize = 0;\n    if ('getStats' in this.storageAdapter) {\n      try {\n        const stats = await (this.storageAdapter as any).getStats();\n        storageSize = stats.size || 0;\n      } catch (error) {\n        console.warn('Failed to get storage stats:', error);\n      }\n    }\n\n    return {\n      totalMemories: allMemories.length,\n      memoriesByType,\n      averageImportance,\n      storageSize\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: MemoryBankConfig): void {\n    this.config = config;\n  }\n\n  /**\n   * Export all memories as JSON\n   */\n  async exportMemories(): Promise<string> {\n    const allMemories = await this.storageAdapter.getAll();\n    return JSON.stringify(allMemories, null, 2);\n  }\n\n  /**\n   * Import memories from JSON\n   */\n  async importMemories(jsonData: string): Promise<number> {\n    try {\n      const memories: Memory[] = JSON.parse(jsonData);\n\n      // Validate and store each memory\n      let importedCount = 0;\n      for (const memory of memories) {\n        try {\n          // Ensure memory has required fields\n          if (!memory.id || !memory.content || !memory.type) {\n            console.warn('Skipping invalid memory:', memory);\n            continue;\n          }\n\n          // Convert date strings to Date objects\n          if (typeof memory.timestamp === 'string') {\n            memory.timestamp = new Date(memory.timestamp);\n          }\n          if (memory.lastAccessed && typeof memory.lastAccessed === 'string') {\n            memory.lastAccessed = new Date(memory.lastAccessed);\n          }\n\n          await this.storageAdapter.store(memory);\n          importedCount++;\n        } catch (error) {\n          console.error('Failed to import memory:', memory, error);\n        }\n      }\n\n      return importedCount;\n    } catch (error) {\n      console.error('Failed to parse import data:', error);\n      throw new Error('Invalid JSON data for import');\n    }\n  }\n\n  /**\n   * Get memories by type\n   */\n  async getMemoriesByType(type: MemoryType): Promise<Memory[]> {\n    return this.storageAdapter.search({ type, limit: 100 });\n  }\n\n  /**\n   * Get recent memories\n   */\n  async getRecentMemories(limit = 20): Promise<Memory[]> {\n    const query: MemoryQuery = {\n      limit,\n      // Sort by timestamp (most recent first) - this would need to be implemented in the adapter\n    };\n\n    return this.storageAdapter.search(query);\n  }\n}","import {\n  Memory,\n  MemoryQuery,\n  MemoryStorageAdapter,\n  MemoryBankConfig,\n  MemoryServiceInterface,\n  MemoryStats,\n  MemoryBankEvents\n} from './types';\nimport { MemoryService } from './services/MemoryService';\n\n/**\n * Core Memory Bank Class\n * Manages memory storage, retrieval, and operations using configurable storage adapters\n */\nexport class MemoryBank implements MemoryServiceInterface {\n  private config: MemoryBankConfig;\n  private memoryService: MemoryService;\n  private eventListeners: Map<keyof MemoryBankEvents, Function[]> = new Map();\n\n  constructor(config: MemoryBankConfig) {\n    this.config = {\n      maxMemories: 1000,\n      defaultImportance: 0.5,\n      enableAutoCleanup: true,\n      cleanupThreshold: 0.8,\n      ...config\n    };\n\n    this.memoryService = new MemoryService(config);\n    this.setupAutoCleanup();\n  }\n\n  /**\n   * Add a new memory to the bank\n   */\n  async addMemory(\n    content: string,\n    type: Memory['type'],\n    metadata?: Record<string, any>\n  ): Promise<Memory> {\n    const memory = await this.memoryService.addMemory(content, type, metadata);\n\n    // Emit event\n    this.emit('memoryAdded', memory);\n\n    return memory;\n  }\n\n  /**\n   * Retrieve a specific memory by ID\n   */\n  async getMemory(id: string): Promise<Memory | null> {\n    return this.memoryService.getMemory(id);\n  }\n\n  /**\n   * Search memories based on query parameters\n   */\n  async searchMemories(query: MemoryQuery): Promise<Memory[]> {\n    const results = await this.memoryService.searchMemories(query);\n\n    // Emit event\n    this.emit('memorySearched', query, results);\n\n    return results;\n  }\n\n  /**\n   * Update an existing memory\n   */\n  async updateMemory(id: string, updates: Partial<Memory>): Promise<void> {\n    const updatedMemory = await this.memoryService.updateMemory(id, updates);\n\n    // Emit event\n    this.emit('memoryUpdated', updatedMemory);\n  }\n\n  /**\n   * Delete a memory from the bank\n   */\n  async deleteMemory(id: string): Promise<void> {\n    await this.memoryService.deleteMemory(id);\n\n    // Emit event\n    this.emit('memoryDeleted', id);\n  }\n\n  /**\n   * Get relevant memories based on context similarity\n   */\n  async getRelevantMemories(context: string, limit = 10): Promise<Memory[]> {\n    return this.memoryService.getRelevantMemories(context, limit);\n  }\n\n  /**\n   * Perform cleanup operations (remove old/low-importance memories)\n   */\n  async cleanup(): Promise<void> {\n    const deletedCount = await this.memoryService.cleanup();\n\n    // Emit event\n    this.emit('cleanupPerformed', deletedCount);\n  }\n\n  /**\n   * Get memory bank statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    return this.memoryService.getStats();\n  }\n\n  /**\n   * Add event listener for memory bank events\n   */\n  on<K extends keyof MemoryBankEvents>(\n    event: K,\n    listener: MemoryBankEvents[K]\n  ): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)!.push(listener);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off<K extends keyof MemoryBankEvents>(\n    event: K,\n    listener: MemoryBankEvents[K]\n  ): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event to all listeners\n   */\n  private emit<K extends keyof MemoryBankEvents>(\n    event: K,\n    ...args: Parameters<MemoryBankEvents[K]>\n  ): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          (listener as any)(...args);\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Setup automatic cleanup if enabled\n   */\n  private setupAutoCleanup(): void {\n    if (this.config.enableAutoCleanup) {\n      // Cleanup every hour if storage is near capacity\n      setInterval(async () => {\n        try {\n          const stats = await this.getStats();\n          if (stats.totalMemories > (this.config.maxMemories || 1000) * (this.config.cleanupThreshold || 0.8)) {\n            await this.cleanup();\n          }\n        } catch (error) {\n          console.error('Auto-cleanup failed:', error);\n        }\n      }, 60 * 60 * 1000); // 1 hour\n    }\n  }\n\n  /**\n   * Get the underlying storage adapter\n   */\n  getStorageAdapter(): MemoryStorageAdapter {\n    return this.config.storageAdapter;\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<MemoryBankConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.memoryService.updateConfig(this.config);\n  }\n}","import { Memory, MemoryQuery, MemoryStorageAdapter } from '../types';\n\n/**\n * Local Storage Adapter for Memory Bank\n * Implements memory storage using browser's localStorage API\n */\nexport class LocalStorageAdapter implements MemoryStorageAdapter {\n  private storageKey = 'memory_bank_memories';\n  private metadataKey = 'memory_bank_metadata';\n\n  constructor(storageKey?: string) {\n    if (storageKey) {\n      this.storageKey = storageKey;\n    }\n  }\n\n  /**\n   * Store a memory in localStorage\n   */\n  async store(memory: Memory): Promise<void> {\n    try {\n      const memories = await this.getAllMemories();\n      const existingIndex = memories.findIndex(m => m.id === memory.id);\n\n      if (existingIndex >= 0) {\n        memories[existingIndex] = memory;\n      } else {\n        memories.push(memory);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(memories));\n      this.updateMetadata();\n    } catch (error) {\n      console.error('Failed to store memory:', error);\n      throw new Error('Failed to store memory in localStorage');\n    }\n  }\n\n  /**\n   * Retrieve a memory by ID\n   */\n  async retrieve(id: string): Promise<Memory | null> {\n    try {\n      const memories = await this.getAllMemories();\n      return memories.find(m => m.id === id) || null;\n    } catch (error) {\n      console.error('Failed to retrieve memory:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Search memories based on query parameters\n   */\n  async search(query: MemoryQuery): Promise<Memory[]> {\n    try {\n      let memories = await this.getAllMemories();\n\n      // Filter by type\n      if (query.type) {\n        memories = memories.filter(m => m.type === query.type);\n      }\n\n      // Filter by minimum importance\n      if (query.minImportance !== undefined) {\n        memories = memories.filter(m => m.importance >= query.minImportance!);\n      }\n\n      // Filter by keywords\n      if (query.keywords && query.keywords.length > 0) {\n        memories = memories.filter(m =>\n          query.keywords!.some(keyword =>\n            m.content.toLowerCase().includes(keyword.toLowerCase())\n          )\n        );\n      }\n\n      // Filter by date range\n      if (query.dateRange) {\n        const start = query.dateRange.start.getTime();\n        const end = query.dateRange.end.getTime();\n        memories = memories.filter(m => {\n          const memoryTime = m.timestamp.getTime();\n          return memoryTime >= start && memoryTime <= end;\n        });\n      }\n\n      // Filter by metadata\n      if (query.metadata) {\n        memories = memories.filter(m =>\n          m.metadata && this.matchesMetadata(m.metadata, query.metadata!)\n        );\n      }\n\n      // Sort by importance and access count (most important and recently accessed first)\n      memories.sort((a, b) => {\n        const aScore = a.importance + (a.accessCount * 0.1);\n        const bScore = b.importance + (b.accessCount * 0.1);\n        return bScore - aScore;\n      });\n\n      // Apply limit\n      if (query.limit) {\n        memories = memories.slice(0, query.limit);\n      }\n\n      return memories;\n    } catch (error) {\n      console.error('Failed to search memories:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Update an existing memory\n   */\n  async update(id: string, updates: Partial<Memory>): Promise<void> {\n    try {\n      const memory = await this.retrieve(id);\n      if (!memory) {\n        throw new Error(`Memory with id ${id} not found`);\n      }\n\n      const updatedMemory: Memory = {\n        ...memory,\n        ...updates,\n        id, // Ensure ID doesn't change\n        timestamp: memory.timestamp // Preserve original timestamp\n      };\n\n      await this.store(updatedMemory);\n    } catch (error) {\n      console.error('Failed to update memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a memory from localStorage\n   */\n  async delete(id: string): Promise<void> {\n    try {\n      const memories = await this.getAllMemories();\n      const filteredMemories = memories.filter(m => m.id !== id);\n\n      if (filteredMemories.length === memories.length) {\n        throw new Error(`Memory with id ${id} not found`);\n      }\n\n      localStorage.setItem(this.storageKey, JSON.stringify(filteredMemories));\n      this.updateMetadata();\n    } catch (error) {\n      console.error('Failed to delete memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all memories from localStorage\n   */\n  async getAll(): Promise<Memory[]> {\n    return this.getAllMemories();\n  }\n\n  /**\n   * Clear all memories from localStorage\n   */\n  async clear(): Promise<void> {\n    try {\n      localStorage.removeItem(this.storageKey);\n      localStorage.removeItem(this.metadataKey);\n    } catch (error) {\n      console.error('Failed to clear memories:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all memories from localStorage with error handling\n   */\n  private async getAllMemories(): Promise<Memory[]> {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (!stored) {\n        return [];\n      }\n\n      const memories = JSON.parse(stored);\n\n      // Convert date strings back to Date objects\n      return memories.map((m: any) => ({\n        ...m,\n        timestamp: new Date(m.timestamp),\n        lastAccessed: m.lastAccessed ? new Date(m.lastAccessed) : undefined\n      }));\n    } catch (error) {\n      console.error('Failed to parse memories from localStorage:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Update metadata about the memory storage\n   */\n  private updateMetadata(): void {\n    try {\n      const metadata = {\n        lastUpdated: new Date(),\n        storageSize: this.getStorageSize()\n      };\n      localStorage.setItem(this.metadataKey, JSON.stringify(metadata));\n    } catch (error) {\n      console.error('Failed to update metadata:', error);\n    }\n  }\n\n  /**\n   * Get current storage size in bytes\n   */\n  private getStorageSize(): number {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      return stored ? new Blob([stored]).size : 0;\n    } catch (error) {\n      console.error('Failed to calculate storage size:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Check if metadata matches the query\n   */\n  private matchesMetadata(memoryMetadata: Record<string, any>, queryMetadata: Record<string, any>): boolean {\n    return Object.entries(queryMetadata).every(([key, value]) => {\n      return memoryMetadata[key] === value;\n    });\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats(): Promise<{ count: number; size: number }> {\n    const memories = await this.getAllMemories();\n    return {\n      count: memories.length,\n      size: this.getStorageSize()\n    };\n  }\n}","import { MemoryBankConfig } from './types';\nimport { LocalStorageAdapter } from './storage/LocalStorageAdapter';\n\n/**\n * Default Memory Bank Configuration\n */\nexport const defaultMemoryBankConfig: MemoryBankConfig = {\n  maxMemories: 1000,\n  defaultImportance: 0.5,\n  storageAdapter: new LocalStorageAdapter('memory_bank_memories'),\n  enableAutoCleanup: true,\n  cleanupThreshold: 0.8\n};\n\n/**\n * Cloud Memory Bank Configuration\n */\nexport const cloudMemoryBankConfig = async (baseUrl: string, apiKey?: string): Promise<MemoryBankConfig> => {\n  const { CloudStorageAdapter } = await import('./storage/CloudStorageAdapter');\n\n  return {\n    maxMemories: 5000,\n    defaultImportance: 0.5,\n    storageAdapter: new CloudStorageAdapter({\n      baseUrl,\n      apiKey,\n      timeout: 15000\n    }),\n    enableAutoCleanup: true,\n    cleanupThreshold: 0.9\n  };\n};\n\n/**\n * Memory Bank Configuration for School Context\n * Optimized for educational content and student interactions\n */\nexport const schoolMemoryBankConfig: MemoryBankConfig = {\n  maxMemories: 2000,\n  defaultImportance: 0.6,\n  storageAdapter: new LocalStorageAdapter('school_memory_bank'),\n  enableAutoCleanup: true,\n  cleanupThreshold: 0.85\n};","// Import Google AI SDK and content types\nimport { GoogleGenAI } from \"@google/genai\";\nimport { MemoryBank, schoolMemoryBankConfig } from '../memory';\nimport { API_KEY, WORKER_URL } from '../utils/envValidation';\n\n// Initialize the Google AI client\nconst ai = new GoogleGenAI({ apiKey: API_KEY });\n\nconst workerUrl = `${WORKER_URL}/api/chat`;\n\n// Initialize memory bank for conversation history\nconst memoryBank = new MemoryBank(schoolMemoryBankConfig);\n\n// This function implements the RAG pattern:\n// 1. Fetches relevant context from our Worker (which queries a vector DB).\n// 2. Augments the user's prompt with this context.\n// 3. Sends the augmented prompt to the Gemini model for a grounded response.\n// 4. Stores conversation in memory bank for future context.\nexport async function* getAIResponseStream(message: string, history: {role: 'user' | 'model', parts: string}[]): AsyncGenerator<string> {\n  let context = \"\";\n  try {\n    // 1. Fetch context from the Worker\n    const contextResponse = await fetch(workerUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ message }),\n    });\n    if (contextResponse.ok) {\n        const data = await contextResponse.json();\n        context = data.context;\n    }\n  } catch(e) {\n      // We can still proceed without context, Gemini will do its best.\n  }\n\n  // 2. Get additional context from memory bank\n  let memoryContext = \"\";\n  try {\n    const relevantMemories = await memoryBank.getRelevantMemories(message, 3);\n    if (relevantMemories.length > 0) {\n      memoryContext = relevantMemories.map(m => m.content).join('\\n---\\n');\n    }\n  } catch (error) {\n    console.warn('Failed to get memory context:', error);\n  }\n\n  // 3. Augment the user's message with the retrieved context\n  let augmentedMessage = message;\n\n  if (context && memoryContext) {\n    augmentedMessage = `Berdasarkan konteks dari website sekolah:\\n---\\n${context}\\n---\\n\\nDan konteks percakapan sebelumnya:\\n---\\n${memoryContext}\\n---\\n\\nJawab pertanyaan ini: ${message}`;\n  } else if (context) {\n    augmentedMessage = `Berdasarkan konteks berikut:\\n---\\n${context}\\n---\\n\\nJawab pertanyaan ini: ${message}`;\n  } else if (memoryContext) {\n    augmentedMessage = `Berdasarkan konteks percakapan sebelumnya:\\n---\\n${memoryContext}\\n---\\n\\nJawab pertanyaan ini: ${message}`;\n  }\n\n  // System instruction for the model\n  const systemInstruction = `Anda adalah 'Asisten MA Malnu Kananga', chatbot AI yang ramah, sopan, dan sangat membantu, berbicara dalam Bahasa Indonesia. Tugas Anda adalah menjawab pertanyaan tentang sekolah MA Malnu Kananga berdasarkan konteks yang diberikan dari website sekolah. Jika konteks tidak cukup untuk menjawab, katakan Anda tidak memiliki informasi tersebut dan sarankan untuk menghubungi pihak sekolah. JANGAN menjawab pertanyaan di luar topik sekolah.`;\n  \n  // Format history for the Gemini API\n  const contents = [\n      ...history.map(h => ({ role: h.role, parts: [{ text: h.parts }] })),\n      { role: 'user', parts: [{ text: augmentedMessage }] }\n  ];\n\n  let fullResponse = \"\";\n\n  try {\n    // 3. Call the Gemini API with the augmented prompt and history\n    const responseStream = await ai.models.generateContentStream({\n        model: 'gemini-2.5-flash',\n        contents,\n        config: {\n            systemInstruction,\n        }\n    });\n\n    for await (const chunk of responseStream) {\n      fullResponse += chunk.text;\n      yield chunk.text;\n    }\n\n    // 4. Store conversation in memory bank for future context\n    try {\n      await memoryBank.addMemory(\n        `Pertanyaan: ${message}\\nJawaban: ${fullResponse}`,\n        'conversation',\n        {\n          type: 'user_ai_interaction',\n          userMessage: message,\n          aiResponse: fullResponse,\n          timestamp: new Date().toISOString(),\n          contextUsed: !!context,\n          memoryContextUsed: !!memoryContext\n        }\n      );\n    } catch (memoryError) {\n      console.warn('Failed to store conversation in memory bank:', memoryError);\n    }\n\n  } catch (error) {\n      yield \"Maaf, terjadi masalah saat menghubungi AI. Silakan coba lagi nanti.\";\n\n      // Store failed interaction in memory bank\n      try {\n        await memoryBank.addMemory(\n          `Pertanyaan: ${message}\\nError: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          'conversation',\n          {\n            type: 'failed_interaction',\n            userMessage: message,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            timestamp: new Date().toISOString()\n          }\n        );\n      } catch (memoryError) {\n        console.warn('Failed to store error in memory bank:', memoryError);\n      }\n  }\n}\n\n\n\n// Memory bank utility functions\nexport async function getConversationHistory(limit = 10) {\n  try {\n    return await memoryBank.searchMemories({\n      type: 'conversation',\n      limit,\n    });\n  } catch (error) {\n    console.error('Failed to get conversation history:', error);\n    return [];\n  }\n}\n\nexport async function clearConversationHistory() {\n  try {\n    const conversations = await memoryBank.searchMemories({\n      type: 'conversation',\n    });\n\n    for (const conversation of conversations) {\n      await memoryBank.deleteMemory(conversation.id);\n    }\n\n    return conversations.length;\n  } catch (error) {\n    console.error('Failed to clear conversation history:', error);\n    throw error;\n  }\n}\n\nexport async function getMemoryStats() {\n  try {\n    return await memoryBank.getStats();\n  } catch (error) {\n    console.error('Failed to get memory stats:', error);\n    return null;\n  }\n}\n\nexport const initialGreeting = \"Assalamualaikum! Saya Asisten AI MA Malnu Kananga. Ada yang bisa saya bantu terkait informasi sekolah, pendaftaran, atau kegiatan?\";","\nimport React from 'react';\n\nexport const SendIcon: React.FC = () => (\n    <svg \n        xmlns=\"http://www.w3.org/2000/svg\" \n        className=\"h-6 w-6 transform rotate-45 -translate-y-px\" \n        fill=\"none\" \n        viewBox=\"0 0 24 24\" \n        stroke=\"currentColor\" \n        strokeWidth={2}\n    >\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n    </svg>\n);","\nimport React, { useState, useRef, useEffect, useCallback } from 'react';\nimport type { ChatMessage } from '../types';\nimport { Sender } from '../types';\nimport { getAIResponseStream, initialGreeting } from '../services/geminiService';\nimport { SendIcon } from './icons/SendIcon';\nimport { CloseIcon } from './icons/CloseIcon'; // Import CloseIcon\n\ninterface ChatWindowProps {\n  isOpen: boolean;\n  closeChat: () => void;\n}\n\nconst ChatWindow: React.FC<ChatWindowProps> = ({ isOpen, closeChat }) => {\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  // State to store the conversation history for the LLM\n  const [history, setHistory] = useState<{role: 'user' | 'model', parts: string}[]>([]);\n  const [input, setInput] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  };\n  \n  useEffect(() => {\n    if (isOpen && messages.length === 0) {\n        setMessages([\n            { id: 'initial', text: initialGreeting, sender: Sender.AI }\n        ]);\n    }\n  }, [isOpen, messages.length]);\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  const handleSend = useCallback(async (e?: React.FormEvent) => {\n    e?.preventDefault();\n    if (!input.trim() || isLoading) return;\n\n    const userMessageText = input;\n    const userMessage: ChatMessage = { id: Date.now().toString(), text: userMessageText, sender: Sender.User };\n    \n    // Add user message to the UI\n    setMessages(prev => [...prev, userMessage]);\n    setInput('');\n    setIsLoading(true);\n    \n    // Add a placeholder for the AI response to the UI\n    const aiMessageId = (Date.now() + 1).toString();\n    setMessages(prev => [...prev, { id: aiMessageId, text: '', sender: Sender.AI }]);\n    \n    let fullResponse = \"\";\n    try {\n      // Send the current message and the previous history to the AI\n      const stream = getAIResponseStream(userMessageText, history);\n      for await (const chunk of stream) {\n        fullResponse += chunk;\n        setMessages(prev =>\n          prev.map(msg =>\n            msg.id === aiMessageId ? { ...msg, text: fullResponse } : msg\n          )\n        );\n      }\n    } catch (error) {\n      const errorMessage = \"Maaf, terjadi kesalahan. Silakan coba lagi.\";\n      setMessages(prev =>\n        prev.map(msg =>\n          msg.id === aiMessageId ? { ...msg, text: errorMessage } : msg\n        )\n      );\n      fullResponse = errorMessage; // Ensure the history records the error\n    } finally {\n      setIsLoading(false);\n      // Once the response is complete, update the history with both the user's message and the AI's full response.\n      setHistory(prev => [...prev, \n        { role: 'user', parts: userMessageText },\n        { role: 'model', parts: fullResponse }\n      ]);\n    }\n  }, [input, isLoading, history]);\n\n  return (\n    <div className=\"flex flex-col h-full bg-white dark:bg-gray-800 rounded-2xl shadow-2xl border border-gray-200 dark:border-gray-700 overflow-hidden\">\n      {/* Header */}\n      <header className=\"flex items-center justify-between p-4 bg-green-600 text-white\">\n        <div className=\"flex items-center\">\n            <div className=\"w-3 h-3 bg-white rounded-full mr-2 animate-pulse\"></div>\n            <h2 className=\"font-bold text-lg\">Asisten AI</h2>\n        </div>\n        <button onClick={closeChat} className=\"p-1 rounded-full hover:bg-white/20\" aria-label=\"Tutup obrolan\">\n            <CloseIcon />\n        </button>\n      </header>\n\n      {/* Messages */}\n      <div className=\"flex-1 p-4 overflow-y-auto bg-gray-50 dark:bg-gray-900\">\n        <div className=\"flex flex-col space-y-4\">\n          {messages.map((message) => (\n            <div\n              key={message.id}\n              className={`flex items-end max-w-xs md:max-w-md gap-2 ${\n                message.sender === Sender.User ? 'self-end flex-row-reverse' : 'self-start'\n              }`}\n            >\n              <div\n                className={`rounded-2xl p-3 text-sm md:text-base ${\n                  message.sender === Sender.User\n                    ? 'bg-green-500 text-white rounded-br-lg'\n                    : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-bl-lg'\n                }`}\n              >\n                {message.text}\n                 {isLoading && message.sender === Sender.AI && !message.text && (\n                    <div className=\"flex items-center justify-center space-x-1\">\n                        <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{animationDelay: '0s'}}></span>\n                        <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{animationDelay: '0.2s'}}></span>\n                        <span className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{animationDelay: '0.4s'}}></span>\n                    </div>\n                 )}\n              </div>\n            </div>\n          ))}\n          <div ref={messagesEndRef} />\n        </div>\n      </div>\n\n      {/* Input */}\n      <div className=\"p-4 border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800\">\n        <form onSubmit={handleSend} className=\"flex items-center space-x-2\">\n          <input\n            type=\"text\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            placeholder=\"Ketik pertanyaan Anda...\"\n            className=\"flex-1 p-3 bg-gray-100 dark:bg-gray-700 rounded-full focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-800 dark:text-gray-200\"\n            disabled={isLoading}\n          />\n          <button\n            type=\"submit\"\n            disabled={isLoading || !input.trim()}\n            className=\"p-3 bg-green-600 text-white rounded-full disabled:bg-gray-400 disabled:cursor-not-allowed hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500\"\n            aria-label=\"Kirim pesan\"\n          >\n            <SendIcon />\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatWindow;"],"names":["validateEnvironment","env","API_KEY","WORKER_URL","Sender","MemoryService","config","content","type","metadata","now","memory","uuidv4","id","query","updates","existing","context","limit","contextWords","score","word","occurrences","daysSinceCreation","recencyBonus","accessBonus","a","b","allMemories","maxMemories","sortedMemories","aScore","bScore","memoriesToDelete","memoriesByType","acc","averageImportance","sum","storageSize","error","jsonData","memories","importedCount","MemoryBank","results","updatedMemory","deletedCount","event","listener","listeners","index","args","newConfig","LocalStorageAdapter","storageKey","existingIndex","m","keyword","start","end","memoryTime","filteredMemories","stored","memoryMetadata","queryMetadata","key","value","schoolMemoryBankConfig","ai","GoogleGenAI","workerUrl","memoryBank","getAIResponseStream","message","history","contextResponse","memoryContext","relevantMemories","augmentedMessage","systemInstruction","contents","h","fullResponse","responseStream","chunk","memoryError","initialGreeting","SendIcon","jsxDEV","this","ChatWindow","isOpen","closeChat","messages","setMessages","useState","setHistory","input","setInput","isLoading","setIsLoading","messagesEndRef","useRef","scrollToBottom","useEffect","handleSend","useCallback","e","userMessageText","userMessage","prev","aiMessageId","stream","msg","errorMessage","CloseIcon"],"mappings":"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"}