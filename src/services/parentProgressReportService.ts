import type { Grade, Attendance } from '../types';
import { analyzeStudentPerformance } from './ai';
import { logger } from '../utils/logger';
import { STORAGE_KEYS, TIME_MS, PROGRESS_REPORT_CONFIG, SERVICE_ERROR_MESSAGES, DATE_LOCALE } from '../constants';

/**
 * Progress Report generated by AI
 * Contains comprehensive analysis of student's learning progress
 */
export interface ProgressReport {
  id: string;
  studentId: string;
  studentName: string;
  parentId: string;
  generatedAt: string;
  reportDate: string;
  analysis: string;
  gradesData: {
    subjects: Array<{
      subject: string;
      score: number;
      grade: string;
      trend: string;
    }>;
    averageScore: number;
  };
  attendanceData: {
    percentage: number;
    totalDays: number;
    present: number;
    absent: number;
  };
  trendsData: Array<{
    month: string;
    averageScore: number;
    attendanceRate: number;
  }>;
}

/**
 * Parent preferences for progress reports
 */
export interface ProgressReportSettings {
  parentId: string;
  frequency: 'weekly' | 'bi-weekly' | 'monthly';
  enableNotifications: boolean;
  quietHoursStart: string; // HH:mm format
  quietHoursEnd: string; // HH:mm format
  lastReportDate?: string;
  nextReportDate?: string;
}

/**
 * Service for generating and managing AI-powered progress reports for parents
 * Uses geminiService for AI analysis and localStorage for persistence
 */
class ParentProgressReportService {
  private readonly CACHE_TTL_DAYS = PROGRESS_REPORT_CONFIG.CACHE_TTL_DAYS;

  /**
   * Generate a new progress report for a student
   */
  async generateProgressReport(
    studentId: string,
    studentName: string,
    parentId: string,
    grades: Grade[],
    attendance: Attendance[],
    forceRefresh: boolean = false
  ): Promise<ProgressReport> {
    try {
      // Check for cached report
      if (!forceRefresh) {
        const cached = this.getCachedReport(studentId, parentId);
        if (cached && this.isCacheValid(cached.generatedAt)) {
          logger.debug('Returning cached progress report');
          return cached;
        }
      }

      // Prepare data for AI analysis
      const gradesData = this.processGradesData(grades);
      const attendanceData = this.processAttendanceData(attendance);
      const trendsData = this.calculateTrends(grades, attendance);

      // Call AI service for analysis
      const analysis = await analyzeStudentPerformance({
        grades: gradesData.subjects,
        attendance: attendanceData,
        trends: trendsData
      });

      // Create report object
      const report: ProgressReport = {
        id: `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        studentId,
        studentName,
        parentId,
        generatedAt: new Date().toISOString(),
        reportDate: new Date().toISOString().split('T')[0],
        analysis,
        gradesData,
        attendanceData,
        trendsData
      };

      // Save to localStorage
      this.saveReport(report);

      logger.info(`Generated progress report for student ${studentId}`);
      return report;
    } catch (error) {
      logger.error('Failed to generate progress report:', error);
      throw new Error(SERVICE_ERROR_MESSAGES.REPORT_GENERATION_FAILED);
    }
  }

  /**
   * Get cached report for a student
   */
  getCachedReport(studentId: string, parentId: string): ProgressReport | null {
    try {
      const key = STORAGE_KEYS.PARENT_PROGRESS_REPORTS(studentId);
      const cached = localStorage.getItem(key);
      if (cached) {
        const reports: ProgressReport[] = JSON.parse(cached);
        const report = reports.find(r => r.studentId === studentId && r.parentId === parentId);
        return report || null;
      }
      return null;
    } catch (error) {
      logger.error('Failed to get cached progress report:', error);
      return null;
    }
  }

  /**
   * Get all reports for a parent
   */
  getParentReports(parentId: string): ProgressReport[] {
    try {
      const allReports: ProgressReport[] = [];
      // Get all keys matching the pattern
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith('malnu_parent_progress_reports_')) {
          const cached = localStorage.getItem(key);
          if (cached) {
            const reports: ProgressReport[] = JSON.parse(cached);
            allReports.push(...reports.filter(r => r.parentId === parentId));
          }
        }
      }
      // Sort by generatedAt descending
      return allReports.sort((a, b) => 
        new Date(b.generatedAt).getTime() - new Date(a.generatedAt).getTime()
      );
    } catch (error) {
      logger.error('Failed to get parent reports:', error);
      return [];
    }
  }

  /**
   * Save report to localStorage
   */
  private saveReport(report: ProgressReport): void {
    try {
      const key = STORAGE_KEYS.PARENT_PROGRESS_REPORTS(report.studentId);
      const cached = localStorage.getItem(key);
      const reports: ProgressReport[] = cached ? JSON.parse(cached) : [];
      
      // Update or add report
      const existingIndex = reports.findIndex(r => r.studentId === report.studentId);
      if (existingIndex >= 0) {
        reports[existingIndex] = report;
      } else {
        reports.push(report);
      }
      
      // Keep only latest reports per student
      const trimmedReports = reports.slice(-PROGRESS_REPORT_CONFIG.MAX_REPORTS_PER_STUDENT);
      
      localStorage.setItem(key, JSON.stringify(trimmedReports));
    } catch (error) {
      logger.error('Failed to save progress report:', error);
    }
  }

  /**
   * Check if cache is still valid
   */
  private isCacheValid(generatedAt: string): boolean {
    const generated = new Date(generatedAt);
    const now = new Date();
    const daysDiff = (now.getTime() - generated.getTime()) / TIME_MS.ONE_DAY;
    return daysDiff < this.CACHE_TTL_DAYS;
  }

  /**
   * Process grades data for AI analysis
   */
  private processGradesData(grades: Grade[]): ProgressReport['gradesData'] {
    const subjectMap = new Map<string, Grade[]>();
    
    grades.forEach(grade => {
      const subject = grade.subjectName || 'Unknown';
      if (!subjectMap.has(subject)) {
        subjectMap.set(subject, []);
      }
      subjectMap.get(subject)!.push(grade);
    });

    const subjects: Array<{ subject: string; score: number; grade: string; trend: string }> = [];
    let totalScore = 0;

    subjectMap.forEach((subjectGrades, subject) => {
      const latestGrade = subjectGrades.sort((a, b) => 
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      )[0];

      const score = latestGrade.score || 0;
      const letterGrade = this.scoreToLetterGrade(score);
      
      subjects.push({
        subject,
        score,
        grade: letterGrade,
        trend: this.calculateSubjectTrend(subjectGrades)
      });

      totalScore += score;
    });

    return {
      subjects,
      averageScore: subjects.length > 0 ? Math.round(totalScore / subjects.length) : 0
    };
  }

  /**
   * Process attendance data for AI analysis
   */
  private processAttendanceData(attendance: Attendance[]): ProgressReport['attendanceData'] {
    if (attendance.length === 0) {
      return {
        percentage: 100,
        totalDays: 0,
        present: 0,
        absent: 0
      };
    }

    const present = attendance.filter(a => a.status === 'hadir').length;
    const totalDays = attendance.length;
    const percentage = totalDays > 0 ? Math.round((present / totalDays) * 100) : 100;

    return {
      percentage,
      totalDays,
      present,
      absent: totalDays - present
    };
  }

  /**
   * Calculate trends from grades and attendance
   */
  private calculateTrends(
    grades: Grade[],
    attendance: Attendance[]
  ): Array<{ month: string; averageScore: number; attendanceRate: number }> {
    const monthlyData = new Map<string, { scores: number[]; present: number; total: number }>();
    
    grades.forEach(grade => {
      const month = new Date(grade.createdAt).toLocaleString('id-ID', { month: 'long', year: 'numeric' });
      if (!monthlyData.has(month)) {
        monthlyData.set(month, { scores: [], present: 0, total: 0 });
      }
      if (grade.score !== null && grade.score !== undefined) {
        monthlyData.get(month)!.scores.push(grade.score);
      }
    });

    attendance.forEach(att => {
      const month = new Date(att.date).toLocaleString('id-ID', { month: 'long', year: 'numeric' });
      if (!monthlyData.has(month)) {
        monthlyData.set(month, { scores: [], present: 0, total: 0 });
      }
      monthlyData.get(month)!.total++;
      if (att.status === 'hadir') {
        monthlyData.get(month)!.present++;
      }
    });

    const trends: Array<{ month: string; averageScore: number; attendanceRate: number }> = [];
    monthlyData.forEach((data, month) => {
      const avgScore = data.scores.length > 0 
        ? Math.round(data.scores.reduce((sum, s) => sum + s, 0) / data.scores.length)
        : 0;
      const attendanceRate = data.total > 0 ? Math.round((data.present / data.total) * 100) : 100;
      
      trends.push({ month, averageScore: avgScore, attendanceRate });
    });

    // Sort by date ascending
    return trends.sort((a, b) => {
      const [monthA, yearA] = a.month.split(' ');
      const [monthB, yearB] = b.month.split(' ');
      
      if (yearA !== yearB) {
        return parseInt(yearA) - parseInt(yearB);
      }
      // Flexy: Using DATE_LOCALE constant from constants.ts instead of hardcoded array
      return DATE_LOCALE.INDONESIAN_MONTHS.indexOf(monthA as typeof DATE_LOCALE.INDONESIAN_MONTHS[number]) - DATE_LOCALE.INDONESIAN_MONTHS.indexOf(monthB as typeof DATE_LOCALE.INDONESIAN_MONTHS[number]);
    });
  }

  /**
   * Calculate subject trend (up/down/stable)
   */
  private calculateSubjectTrend(subjectGrades: Grade[]): string {
    if (subjectGrades.length < 2) return 'stable';
    
    const sortedGrades = subjectGrades.sort((a, b) => 
      new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    );
    
    const first = sortedGrades[0].score || 0;
    const last = sortedGrades[sortedGrades.length - 1].score || 0;
    const diff = last - first;
    
    if (diff > PROGRESS_REPORT_CONFIG.GRADE_TREND_THRESHOLD) return 'up';
    if (diff < -PROGRESS_REPORT_CONFIG.GRADE_TREND_THRESHOLD) return 'down';
    return 'stable';
  }

  /**
   * Convert numeric score to letter grade
   */
  private scoreToLetterGrade(score: number): string {
    if (score >= PROGRESS_REPORT_CONFIG.LETTER_GRADE_THRESHOLDS.A) return 'A';
    if (score >= PROGRESS_REPORT_CONFIG.LETTER_GRADE_THRESHOLDS.B) return 'B';
    if (score >= PROGRESS_REPORT_CONFIG.LETTER_GRADE_THRESHOLDS.C) return 'C';
    if (score >= PROGRESS_REPORT_CONFIG.LETTER_GRADE_THRESHOLDS.D) return 'D';
    return 'E';
  }

  /**
   * Get parent report settings
   */
  getSettings(parentId: string): ProgressReportSettings | null {
    try {
      const key = STORAGE_KEYS.PARENT_REPORT_SETTINGS(parentId);
      const cached = localStorage.getItem(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.error('Failed to get report settings:', error);
      return null;
    }
  }

  /**
   * Save parent report settings
   */
  saveSettings(settings: ProgressReportSettings): void {
    try {
      const key = STORAGE_KEYS.PARENT_REPORT_SETTINGS(settings.parentId);
      localStorage.setItem(key, JSON.stringify(settings));
      logger.info(`Saved report settings for parent ${settings.parentId}`);
    } catch (error) {
      logger.error('Failed to save report settings:', error);
    }
  }

  /**
   * Get default settings
   */
  getDefaultSettings(parentId: string): ProgressReportSettings {
    return {
      parentId,
      frequency: PROGRESS_REPORT_CONFIG.DEFAULT_SETTINGS.frequency,
      enableNotifications: PROGRESS_REPORT_CONFIG.DEFAULT_SETTINGS.enableNotifications,
      quietHoursStart: PROGRESS_REPORT_CONFIG.DEFAULT_SETTINGS.quietHoursStart,
      quietHoursEnd: PROGRESS_REPORT_CONFIG.DEFAULT_SETTINGS.quietHoursEnd
    };
  }

  /**
   * Check if a report should be generated based on settings
   */
  shouldGenerateReport(parentId: string): boolean {
    const settings = this.getSettings(parentId);
    if (!settings || !settings.enableNotifications) {
      return false;
    }

    const lastReport = settings.lastReportDate;
    if (!lastReport) {
      return true;
    }

    const last = new Date(lastReport);
    const now = new Date();
    const daysDiff = Math.floor((now.getTime() - last.getTime()) / TIME_MS.ONE_DAY);

    switch (settings.frequency) {
      case 'weekly':
        return daysDiff >= 7;
      case 'bi-weekly':
        return daysDiff >= 14;
      case 'monthly':
        return daysDiff >= 30;
      default:
        return false;
    }
  }

  /**
   * Delete report
   */
  deleteReport(reportId: string, studentId: string): boolean {
    try {
      const key = STORAGE_KEYS.PARENT_PROGRESS_REPORTS(studentId);
      const cached = localStorage.getItem(key);
      if (cached) {
        const reports: ProgressReport[] = JSON.parse(cached);
        const filtered = reports.filter(r => r.id !== reportId);
        localStorage.setItem(key, JSON.stringify(filtered));
        return true;
      }
      return false;
    } catch (error) {
      logger.error('Failed to delete report:', error);
      return false;
    }
  }

  /**
   * Clear all reports for a student
   */
  clearStudentReports(studentId: string): void {
    try {
      const key = STORAGE_KEYS.PARENT_PROGRESS_REPORTS(studentId);
      localStorage.removeItem(key);
      logger.info(`Cleared reports for student ${studentId}`);
    } catch (error) {
      logger.error('Failed to clear reports:', error);
    }
  }
}

export const parentProgressReportService = new ParentProgressReportService();
